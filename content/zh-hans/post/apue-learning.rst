---
title: "APUE 学习笔记"
date: 2019-12-23T14:30:27+08:00
---

这本 APUE 虽然买了很久了，但是没怎么看，因为感觉更像是一个 API 手册，而不是一本用来学习的书。沉下心来才发现我错了。

当然关于函数的使用和一些参数，我依然是选择粗看，稍微了解即可，以后用到的时候再查。

#. 文件 I/O
    #. 打开文件的数据关系
        #. 进程表项包含文件描述符和其对应的文件指针
        #. 文件指针指向文件表项
        #. 文件表项指向 v 节点信息
        #. v 节点信息中的 `v_data` 指向 i 节点

    #. 文件空洞
        在使用 `lseek()` 时，文件偏移量可以大于文件当前长度，这种情况下，对文件的下次写入将加长该文件的长度，并在文件中构成空洞。

        空洞并不占用磁盘空间，具体处理方式和文件系统的实现有关，当定位到炒熟文件尾端之后写入时，对于新写的数据需要分配磁盘块，而原文件尾端和新开始写的位置之间的部分则不分配磁盘块。

    #. `O_APPEND` 和 `lseek()`
        `lseek()` 会被 `O_APPEND` 抵消掉

    #. 文件读写的原子操作
        #. `open` 函数的 `O_APPEND` 选项
        #. 函数 `pread` 和 `pwrite`，相当于调用 `lseek` 后调用 `read`、`write`，但与顺序调用有以下区别：
            #. 调用 `pread`、`pwrite` 时，无法中断其定位和读写操作
            #. 不更新当前文件的偏移量
        #. 同时指定 `open` 函数的 `O_CREAT` 和 `O_EXCL` 选项时，若文件已存在，`open` 将失败
            若没有使用这样的原子操作，而使用 `open` 然后 `creat` 的操作，在 `open` 和 `creat` 之间，若别的程序创建了该文件，并且写入了数据，写入的数据将会被擦去

    #. 调用 `dup`、`dup2` 和使用 `F_DUPED` 的 `fcntl` 后，新的文件描述符与原文件描述符的文件指针指向同一个文件表项

    #. `sync` 只是将所有修改过的块缓冲排入写队列，然后返回，并不等待实际的写磁盘操作结束

    #. `fcntl` 的五个访问方式标志（`O_RDONLY`、`O_WRONLY`、`O_RDWR`、`O_EXEC`、`O_SEARCH`）并不各占一位，前三个标志分别是 `0`、`1`、`2`。这五个值互斥，一个文件的访问方式只能取这五个值之一。因此，必须用屏蔽字 `O_ACCMODE` 取得访问方式位，然后将结果与这五个值启动的每一个比较。

    #. `/dev/fd`
        `/dev/fd` 目录下有名为 `0`、`1`、`2` 的文件，打开 `/dev/fd/n` 相当于复制描述符 `n`（假定描述符 `n` 是打开的）

        Linux 实现的 `/dev/fd` 是个例外，他吧文件描述符映射成或指向底层物理文件的符号链接。例如打开 `/dev/fd/0` 时，事实上正在打开与标准输入相关联的文件，因此返回的新描述符与 `/dev/fd` 文件描述符的格式并不相关

        Linux 上在 `/dev/fd` 使用 `creat` 会导致文件被截断

#. 文件和目录
    #. 文件类型
        #. 普通文件（regular file）
        #. 目录文件（directory file）
        #. 块特殊文件（block special file）：提供对设备带缓冲的访问（FreeBSD 不再支持块特殊文件，只支持字符特殊文件）
        #. 字符特殊文件（character special file）：对设备提供不带缓冲的访问
        #. FIFO：用于进程间通信，也称命名管道（named pipe）
        #. 套接字（socket）：用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信
        #. 符号链接（symbolic link）：用来指向另一个文件

    #. 粘着位
        如果一个目录设置了粘着位，那么只有对该目录具有写权限，并且满足以下条件之一才能删除或重命名该目录下的文件：
            * 拥有此文件
            * 拥有此目录
            * 是超级用户

        目录 `/tmp` 和　`/var/tmp` 是设置粘着位的典型候选者：任何用户都可以在这俩目录中创建文件，但不可以删除、重命名属于其他人的文件

    #. 文件系统
        每个 i 节点都有一个链接计数，其值是指向该 i 节点的目录项数。

        只有当链接计数减少至 0，并且没有进程打开该文件时，才会删除该文件的内容。

    #. 文件的时间
        #. `st_atim`：文件数据最后访问时间，如 `read`
        #. `st_mtim`：文件数据最后修改时间，如 `write`
        #. `st_ctim`：i 节点状态最后更改时间，如 `chmod`、`chown`

    #. 设备特殊文件
        #. 系统中与每个文件名关联的 `st_dev` 值是文件系统的设备号，该文件系统包含这个文件名与其对应的 i 节点
        #. 只有字符特殊文件和块特殊文件才有 `st_rdev` 值，包含实际设备的设备号

#. 进程环境
    #. 八种方式使进程终止
        #. 正常终止
            #. 调用 exit
            #. 调用 _exit 或 _Exit
            #. 最后一个线程从其启动例程返回
            #. 在最后一个线程中调用 pthread_exit
        #. 异常终止
            #. 调用 abort
            #. 接到一个信号
            #. 最后一个线程对取消请求作出响应

    #. exit、_exit、_Exit
        #. exit、_Exit 是 ISO C 说明的，而 _exit 是 POSIX.1 说明的
        #. _exit、_Exit 立即进入内核，而 exit 总是执行标准 I/O 库的清理关闭操作，所以输出缓冲中的数据都会被冲洗（写到文件中）

    #. putenv、setenv
        setenv 必须分配存储空间，以便依据参数创建 `name=value` 字符串

        而 putenv 可以将传给他的参数直接放到环境中。因此，将存放在栈中的字符串作为参数传给 putenv 会发生错误，因为从当前函数返回时，其栈帧占用的存储区可能会被重用。


#. 进程控制
    #. init
        #. 进程 ID 通常是 1
        #. 在自举过程结束时由内核调用
        #. 负责在自举内核后启动一个 Unix 系统
        #. 读取与系统有关的初始化文件，如 `/etc/rc*`、`/etc/inittab` 以及 `etc/init.d` 中的文件
        #. 将系统引导到一个状态（如多用户）

    #. fork
        #. 父进程和子进程共享的属性
            #. 文件描述符
            #. 实际用户/组 ID、有效用户/组 ID
            #. 附属组 ID
            #. 进程组 ID
            #. 会话 ID
            #. 控制终端
            #. 设置用户/组 ID 标志
            #. 当前工作目录
            #. 根目录
            #. 文件模式创建屏蔽字
            #. 信号屏蔽和安排
            #. 对任一打开文件描述符的执行时关闭（close-on-exec）标志
            #. 环境
            #. 连接的共享存储段
            #. 存储映像
            #. 资源限制
        #. 父进程和子进程的区别
            #. fork 返回值不同
            #. 进程 ID 不同
            #. 父进程 ID 不同
            #. 子进程的 tms_utime、tms_stime、tms_cutime、tms_ustime 的值设置为 0
            #. 子进程不继承父进程的文件锁
            #. 子进程的未处理闹钟被清除
            #. 子进程的未处理信号集设置为空集

    #. 僵死进程
        一个已经终止，但其父进程尚未对其进行善后处理（获得子进程有关信息、释放它仍占用的资源）的进程，被称为僵死进程（zombie）

    #. exec
        当进程调用 exec 函数时，该进程执行的程序会被完全替换为新程序，新程序从其 main 函数开始执行，因为 exec 不创建新进程，所以前后的进程 ID 并未改变。exec 只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段

    #. `system` 函数的实现：先 `fork`，然后 `exec`
