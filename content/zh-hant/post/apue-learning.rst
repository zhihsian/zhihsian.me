---
title: "APUE 學習筆記"
date: 2019-12-23T14:30:27+08:00
---

這本 APUE 雖然買了很久了，但是沒怎麼看，因爲感覺更像是一個 API 手冊，而不是一本用來學習的書。沉下心來才發現我錯了。

當然關於函數的使用和一些參數，我依然是選擇粗看，稍微瞭解即可，以後用到的時候再查。

#. 文件 I/O
    #. 打開文件的數據關係
        #. 進程表項包含文件描述符和其對應的文件指針
        #. 文件指針指向文件表項
        #. 文件表項指向 v 節點信息
        #. v 節點信息中的 `v_data` 指向 i 節點

    #. 文件空洞
        在使用 `lseek()` 時，文件偏移量可以大於文件當前長度，這種情況下，對文件的下次寫入將加長該文件的長度，並在文件中構成空洞。

        空洞並不佔用磁盤空間，具體處理方式和文件系統的實現有關，當定位到炒熟文件尾端之後寫入時，對於新寫的數據需要分配磁盤塊，而原文件尾端和新開始寫的位置之間的部分則不分配磁盤塊。

    #. `O_APPEND` 和 `lseek()`
        `lseek()` 會被 `O_APPEND` 抵消掉

    #. 文件讀寫的原子操作
        #. `open` 函數的 `O_APPEND` 選項
        #. 函數 `pread` 和 `pwrite`，相當於調用 `lseek` 後調用 `read`、`write`，但與順序調用有以下區別：
            #. 調用 `pread`、`pwrite` 時，無法中斷其定位和讀寫操作
            #. 不更新當前文件的偏移量
        #. 同時指定 `open` 函數的 `O_CREAT` 和 `O_EXCL` 選項時，若文件已存在，`open` 將失敗
            若沒有使用這樣的原子操作，而使用 `open` 然後 `creat` 的操作，在 `open` 和 `creat` 之間，若別的程序創建了該文件，並且寫入了數據，寫入的數據將會被擦去

    #. 調用 `dup`、`dup2` 和使用 `F_DUPED` 的 `fcntl` 後，新的文件描述符與原文件描述符的文件指針指向同一個文件表項

    #. `sync` 只是將所有修改過的塊緩衝排入寫隊列，然後返回，並不等待實際的寫磁盤操作結束

    #. `fcntl` 的五個訪問方式標誌（`O_RDONLY`、`O_WRONLY`、`O_RDWR`、`O_EXEC`、`O_SEARCH`）並不各佔一位，前三個標誌分別是 `0`、`1`、`2`。這五個值互斥，一個文件的訪問方式只能取這五個值之一。因此，必須用屏蔽字 `O_ACCMODE` 取得訪問方式位，然後將結果與這五個值啓動的每一個比較。

    #. `/dev/fd`
        `/dev/fd` 目錄下有名爲 `0`、`1`、`2` 的文件，打開 `/dev/fd/n` 相當於複製描述符 `n`（假定描述符 `n` 是打開的）

        Linux 實現的 `/dev/fd` 是個例外，他吧文件描述符映射成或指向底層物理文件的符號鏈接。例如打開 `/dev/fd/0` 時，事實上正在打開與標準輸入相關聯的文件，因此返回的新描述符與 `/dev/fd` 文件描述符的格式並不相關

        Linux 上在 `/dev/fd` 使用 `creat` 會導致文件被截斷

#. 文件和目錄
    #. 文件類型
        #. 普通文件（regular file）
        #. 目錄文件（directory file）
        #. 塊特殊文件（block special file）：提供對設備帶緩衝的訪問（FreeBSD 不再支持塊特殊文件，只支持字符特殊文件）
        #. 字符特殊文件（character special file）：對設備提供不帶緩衝的訪問
        #. FIFO：用於進程間通信，也稱命名管道（named pipe）
        #. 套接字（socket）：用於進程間的網絡通信，也可用於在一臺宿主機上進程之間的非網絡通信
        #. 符號鏈接（symbolic link）：用來指向另一個文件

    #. 粘着位
        如果一個目錄設置了粘着位，那麼只有對該目錄具有寫權限，並且滿足以下條件之一才能刪除或重命名該目錄下的文件：
            * 擁有此文件
            * 擁有此目錄
            * 是超級用戶

        目錄 `/tmp` 和　`/var/tmp` 是設置粘着位的典型候選者：任何用戶都可以在這倆目錄中創建文件，但不可以刪除、重命名屬於其他人的文件

    #. 文件系統
        每個 i 節點都有一個鏈接計數，其值是指向該 i 節點的目錄項數。

        只有當鏈接計數減少至 0，並且沒有進程打開該文件時，才會刪除該文件的內容。

    #. 文件的時間
        #. `st_atim`：文件數據最後訪問時間，如 `read`
        #. `st_mtim`：文件數據最後修改時間，如 `write`
        #. `st_ctim`：i 節點狀態最後更改時間，如 `chmod`、`chown`

    #. 設備特殊文件
        #. 系統中與每個文件名關聯的 `st_dev` 值是文件系統的設備號，該文件系統包含這個文件名與其對應的 i 節點
        #. 只有字符特殊文件和塊特殊文件纔有 `st_rdev` 值，包含實際設備的設備號

#. 進程環境
    #. 八種方式使進程終止
        #. 正常終止
            #. 調用 exit
            #. 調用 _exit 或 _Exit
            #. 最後一個線程從其啓動例程返回
            #. 在最後一個線程中調用 pthread_exit
        #. 異常終止
            #. 調用 abort
            #. 接到一個信號
            #. 最後一個線程對取消請求作出響應

    #. exit、_exit、_Exit
        #. exit、_Exit 是 ISO C 說明的，而 _exit 是 POSIX.1 說明的
        #. _exit、_Exit 立即進入內核，而 exit 總是執行標準 I/O 庫的清理關閉操作，所以輸出緩衝中的數據都會被沖洗（寫到文件中）

    #. putenv、setenv
        setenv 必須分配存儲空間，以便依據參數創建 `name=value` 字符串

        而 putenv 可以將傳給他的參數直接放到環境中。因此，將存放在棧中的字符串作爲參數傳給 putenv 會發生錯誤，因爲從當前函數返回時，其棧幀佔用的存儲區可能會被重用。


#. 進程控制
    #. init
        #. 進程 ID 通常是 1
        #. 在自舉過程結束時由內核調用
        #. 負責在自舉內核後啓動一個 Unix 系統
        #. 讀取與系統有關的初始化文件，如 `/etc/rc*`、`/etc/inittab` 以及 `etc/init.d` 中的文件
        #. 將系統引導到一個狀態（如多用戶）

    #. fork
        #. 父進程和子進程共享的屬性
            #. 文件描述符
            #. 實際用戶/組 ID、有效用戶/組 ID
            #. 附屬組 ID
            #. 進程組 ID
            #. 會話 ID
            #. 控制終端
            #. 設置用戶/組 ID 標誌
            #. 當前工作目錄
            #. 根目錄
            #. 文件模式創建屏蔽字
            #. 信號屏蔽和安排
            #. 對任一打開文件描述符的執行時關閉（close-on-exec）標誌
            #. 環境
            #. 連接的共享存儲段
            #. 存儲映像
            #. 資源限制
        #. 父進程和子進程的區別
            #. fork 返回值不同
            #. 進程 ID 不同
            #. 父進程 ID 不同
            #. 子進程的 tms_utime、tms_stime、tms_cutime、tms_ustime 的值設置爲 0
            #. 子進程不繼承父進程的文件鎖
            #. 子進程的未處理鬧鐘被清除
            #. 子進程的未處理信號集設置爲空集

    #. 僵死進程
        一個已經終止，但其父進程尚未對其進行善後處理（獲得子進程有關信息、釋放它仍佔用的資源）的進程，被稱爲僵死進程（zombie）

    #. exec
        當進程調用 exec 函數時，該進程執行的程序會被完全替換爲新程序，新程序從其 main 函數開始執行，因爲 exec 不創建新進程，所以前後的進程 ID 並未改變。exec 只是用磁盤上的一個新程序替換了當前進程的正文段、數據段、堆段和棧段

    #. `system` 函數的實現：先 `fork`，然後 `exec`
